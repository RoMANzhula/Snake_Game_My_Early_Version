import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.util.Random;

public class FieldGame extends JPanel implements ActionListener { // клас ПолеІгри, який містить безпосередньо
    // логіку малювання гри (завдяки батьківському класу JPanel)
    private final int SIZE = 336; // розмір поля
    private final int IMAGE_SIZE = 16; // кількість пікселів, які буде займати наше яблучко і кожен елемент змії
    private final int ALL_CELLS = 400; // кількість ігрових одиниць, які можуть поміститися на ігровому полі
    private Image snakeCell; // створюємо картинку під ігрову клітинку змії
    private Image apple; // створюємо картинку під ігрове яблучко
    private int apple_X; // змінна для позиції X для яблучка
    private int apple_Y; // змінна для позиції Y для яблучка
    private int[] x = new int[ALL_CELLS]; // масив для зберігання положення змії по X розміром на все поле
    private int[] y = new int[ALL_CELLS]; // масив для зберігання положення змії по Y розміром на все поле
    private int snakeCells; // змінна - розмір змії (початковий буде = 3)
    private Timer timer; // стандартний swing-овий таймер
    private boolean left = false; // логічне поле для руху змії ЛІВО
    private boolean right = true; // логічне поле для руху змії ПРАВО
    private boolean up = false; // логічне поле для руху змії ВГОРУ
    private boolean down = false; // логічне поле для руху змії ВНИЗ
    private boolean inGame = true; // логічне поле: ІГРА ЗАПУЩЕНА

    public FieldGame() { // конструктор класу
        setBackground(Color.black); // задаємо колір ігрового поля
        loadingImages(); // викликаємо метод для завантаження картинок
        initializationGame(); // ініціалізуємо нашу гру в конструкторі, викликавши відповідний метод
        addKeyListener(new FieldKeyListener()); // метод для виклику обробника подій з аргументом новий об'єкт
        // нашого класу, що розширює клас KeyAdapter
        setFocusable(true); // метод для фокусування уваги програми на управлінні грою відповідно до ігрового двигуна
    }

    public void initializationGame() { // метод для ініціалізації гри
        snakeCells = 3;
        for (int i = 0; i < snakeCells; i++) {
            x[i] = 48 - (i * IMAGE_SIZE); // початкові координати для змії по осі X (три клітинки змії по 16 пікселів)
            y[i] = 48; // початкові координати для змії по осі Y
        }
        timer = new Timer(300, this); // таймер тикає з частотою 0,3 секунди, і екземпляр цього класу
        // буде відповідати за обробку цього таймера (кожен тик) - для цього ми імплементуємо інтерфейс ActionListener
        // який містить метод actionPerformed() для перевірок колізій в нашій грі (стіна або з'їсти свій хвіст)
        timer.start(); // запускаємо таймер

        createApple(); // викликаємо метод - створити яблучко
    }

    public void createApple() { // метод для створення нового яблучка на ігровому полі
        apple_X = new Random().nextInt(20) * IMAGE_SIZE; // для осі X, враховуючи розмір картинки (16 пікселів) по
        // відношенню до ігрового поля, може поміститися 20 (від 0 до 19) позицій і множимо його на розмірність поля
        apple_Y = new Random().nextInt(20) * IMAGE_SIZE; // для осі Y, враховуючи розмір картинки (16 пікселів) по
        // відношенню до ігрового поля, може поміститися 20 (від 0 до 19) позицій і множимо його на розмірність поля
    }

    public void loadingImages() { // метод для завантаження картинок (розмір картинок має бути 16x16 пікселів)
        ImageIcon imageIconApple = new ImageIcon("apple.png"); // створюємо новий об'єкт класу ImageIcon
        // під відповідним іменем
        apple = imageIconApple.getImage(); // ініціалізуємо поле класу "яблучко"

        ImageIcon imageIconSnakeCell = new ImageIcon("ball.png"); // створюємо новий об'єкт класу ImageIcon
        // під відповідним іменем
        snakeCell = imageIconSnakeCell.getImage(); // ініціалізуємо поле класу "клітинка"
    }

    @Override
    protected void paintComponent(Graphics g) { // переозначений метод, який малює наше ігрове поле
        super.paintComponent(g); // технічне перерисування методу
        if (inGame) { // якщо ми в грі, то
            g.drawImage(apple, apple_X, apple_Y, this); // перерисовуємо картинку яблука (this - об'єкт,
            // який відповідає за картинку, тобто об'єкт, який перерисовує)

            for (int i = 0; i < snakeCells; i++) { // за допомогою циклу перерисовуємо нашу змійку (скільки елементів, стільки
                // перерисовок)
                g.drawImage(snakeCell, x[i], y[i], this); // малюється елемент змійки (всі елементи однакові)
            }
        } else {
            String gameOver = "GAME OVER!"; // створюємо рядкову змінну і ініціалізуємо її літералом КІНЕЦЬ ІГРИ
            Font fontGameOver = new Font("Arial", Font.BOLD, 18); // створюємо новий об'єкт шрифт з аргументами
            // назва шрифта/розмір/жирний шрифт
            g.setColor(Color.red); // встановлюємо колір рядку
            g.setFont(fontGameOver); // встановлюємо рядку створений шрифт
            g.drawString(gameOver, 110, SIZE/2); // малюємо нашу фразу для програшу
        }
    }

    public void move() { // метод для руху змійки, буде відбуватись логічне перерисування точок, будуть зсуватись в
        // масиві X та Y, які ми задали для збереження позицій клітин
        for (int i = snakeCells; i > 0; i--) {
            x[i] = x[i - 1]; // виконуємо зсув точок по X (які не голова) на попередні позиції
            y[i] = y[i - 1]; // виконуємо зсув точок по Y (які не голова) на попередні позиції
        }
        if (left) { // якщо напрямок голови ВЛІВО, то
            x[0] -= IMAGE_SIZE; // беремо наш нульовий X і переміщаємо його на мінус розмір клітин
        }
        if (right) { // якщо напрямок голови ВПРАВО, то
            x[0] += IMAGE_SIZE; // беремо наш нульовий X і переміщаємо його на плюс розмір клітин
        }
        if (up) { // якщо напрямок голови ВВЕРХ, то
            y[0] -= IMAGE_SIZE; // беремо наш нульовий Y і переміщаємо його на мінус розмір клітин
        }
        if (down) { // якщо напрямок голови ВНИЗ, то
            y[0] += IMAGE_SIZE; // беремо наш нульовий Y і переміщаємо його на плюс розмір клітин
        }
    }

    public void checkAppleOnTheWay() { // метод, який перевіряє, чи зустріли ми яблуко на шляху
        if (x[0] == apple_X && y[0] == apple_Y) { // якщо координати голови змійки будуть рівні координатам яблука, то
            snakeCells++; // збільшуємо довжину тіла змійки
            createApple(); // і створюємо нове випадкове яблуко на ігровому полі
        }
    }

    public void checkCollisionWithUs() { // перевіряємо, чи не врізались ми самі в себе
        for (int i = snakeCells; i > 0; i--) {
            if (i > 4 && x[0] == x[i] && y[0] == y[i]) { // якщо довжина змійки більше 4 клітин (тільки так можна наткнутись
                // на себе) і голова не вперлася в наше ж тіло, то
                inGame = false; // кінець гри
            }
        }
    }

    public void checkCollisionWithFields() { // перевіряємо, чи не врізались ми в стіни
        if (x[0] >= SIZE) { // якщо координата голови змійки по X вийшла за межі поля правої сторони, то
            inGame = false; // кінець гри
        }
        if (x[0] < 0) { // якщо координата голови змійки по X вийшла за межі поля лівої сторони, то
            inGame = false; // кінець гри
        }
        if (y[0] >= SIZE) { // якщо координата голови змійки по Y вийшла за межі поля правої сторони, то
            inGame = false; // кінець гри
        }
        if (y[0] < 0) { // якщо координата голови змійки по Y вийшла за межі поля лівої сторони, то
            inGame = false; // кінець гри
        }
    }

    @Override
    public void actionPerformed(ActionEvent e) { // метод для перевірки ActionPerformed()
        // цей метод буде викликатись кожні 300 мілісекунд, які ми
        // встановили при створенні нового таймера в методі ініціалізаціяГри()
        if (inGame) { // якщо ми в грі, то
            checkAppleOnTheWay(); // викликаємо метод, який перевіряє, чи зустріли ми яблуко на шляху
            checkCollisionWithUs(); // викликаємо метод, який перевіряє, чи не врізались ми в своє тіло
            checkCollisionWithFields(); // викликаємо метод, який перевіряє, чи не врізались ми в стіни ігрового поля
            move(); // викликаємо метод руху()
        }
        repaint(); // метод, який викликає метод paintComponent(), який перерисовує поле (може викликатись нами,
        // а може викликатись автоматично операційною системою)
    }

    class FieldKeyListener extends KeyAdapter { // клас ОбробникПодій, який розширює клас KeyAdapter

        @Override
        public void keyPressed(KeyEvent e) {
            super.keyPressed(e);
            int key = e.getKeyCode(); // створюємо змінну, якій присвоюємо значення, рівне отриманому коду клавіші
            // яка була натиснута
            if (key == KeyEvent.VK_LEFT && !right) { // якщо натиснута кнопка вліво і я не рухаюсь вправо (що координально
                // неможливо, оскільки рухатися можна тільки вгору чи вниз перед поворотом)
                left = true; // напрямок вліво - істинно
                up = false; // - хибно
                down = false; // - хибно
            }
            if (key == KeyEvent.VK_RIGHT && !left) { // якщо натиснута кнопка вправо і я не рухаюсь вліво (що координально
                // неможливо, оскільки рухатися можна тільки вгору чи вниз перед поворотом)
                right = true; // напрямок вправо - істинно
                up = false; // - хибно
                down = false; // - хибно
            }
            if (key == KeyEvent.VK_UP && !down) { // якщо натиснута кнопка вгору і я не рухаюсь вниз (що координально
                // неможливо, оскільки рухатися можна тільки вправо чи вліво перед поворотом)
                right = false; // - хибно
                up = true; // напрямок вгору - істинно
                left = false; // - хибно
            }
            if (key == KeyEvent.VK_DOWN && !up) { // якщо натиснута кнопка вниз і я не рухаюсь вгору (що координально
                // неможливо, оскільки рухатися можна тільки вправо чи вліво перед поворотом)
                right = false; // - хибно
                down = true; // напрямок вниз - істинно
                left = false; // - хибно
            }
        }
    }

}
