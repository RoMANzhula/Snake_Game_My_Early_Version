import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.util.Random;

public class FieldGame extends JPanel implements ActionListener { //класс ПолеИгры, который содержит непосредственно
    //логику отрисовки игры (благодаря классу родителю JPanel)
    private final int SIZE = 336; //размер поля
    private final int IMAGE_SIZE = 16; //количество пикселей, которое будет занимать наше яблочко и каждый элемент змейки
    private final int ALL_CELLS = 400; //количество игровых единиц, которое может поместиться на игровом поле
    private Image snakeCell; //создаем картинку под игровую ячейку змейки
    private Image apple; //создаем картинку под игровое яблоко
    private int apple_X; //переменная для позиции Х для яблока
    private int apple_Y; //переменная для позиции У для яблока
    private int[] x = new int[ALL_CELLS]; // массив дял хранения положения змейки по х размером на все поле
    private int[] y = new int[ALL_CELLS]; // массив дял хранения положения змейки по y размером на все поле
    private int snakeCells; //переменная - размер змейки (начальный будет = 3)
    private Timer timer; //стандартный swing-овый таймер
    private boolean left = false; //логическое поле движение змейки ВЛЕВО
    private boolean right = true; //логическое поле движение змейки ВПРАВО
    private boolean up = false; //логическое поле движение змейки ВВЕРХ
    private boolean down = false; //логическое поле движение змейки ВНИЗ
    private boolean inGame = true; //логическое поле ЗАПУЩЕНА ЛИ ИГРА

    public FieldGame() { //конструктор класса
        setBackground(Color.black); //задаем цвет игрового поля
        loadingImages(); //вызываем метод загрузить картинки
        initializationGame(); //инициализируем нашу игру в конструкторе, вызвав соответствующий метод
        addKeyListener(new FieldKeyListener()); //метод для вызова обработчика событий с аргументом новый обьект
        //нашего класса расширяющего класс KeyAdapter
        setFocusable(true); //метод для фокуссировки внимания программы на управление игрой согласно игрового движка
    }

    public void initializationGame() { //метод для Инициализации игры
        snakeCells = 3;
        for (int i = 0; i < snakeCells; i++) {
            x[i] = 48 - (i * IMAGE_SIZE); //начальные координаты для змейки по оси Х (три ячейки змейки х 16 пикселей)
            y[i] = 48; //начальные координаты для змейки по оси У
        }
        timer = new Timer(300, this); //таймер тикает с частотой 0,3 секунды и экземпляр данного класса
        //будет отвечать за обработку данного таймера (каждый тик) - для этого мы имплементируем интерфейс ActionListener
        //который содержит метод actionPerformed() для проверок коллизий в нашей игре (стена или сьесть свой хвост)
        timer.start(); //запускаем таймер

        createApple(); //вызываем метод - создать яблоко
    }

    public void createApple() { //метод для создания нового яблока на игровом поле
        apple_X = new Random().nextInt(20) * IMAGE_SIZE; //для оси Х, учитывая размер картинки (16 пикселей) по
        //отношению игрового поля, может поместиться 20 (от 0 до 19) позиций и умножаем его на размерность поля
        apple_Y = new Random().nextInt(20) * IMAGE_SIZE; //для оси У, учитывая размер картинки (16 пикселей) по
        //отношению игрового поля, может поместиться 20 (от 0 до 19) позиций и умножаем его на размерность поля
    }

    public void loadingImages() { //метод для загрузки картинок (разрешение картинок должно быть 16х16 пикселей)
        ImageIcon imageIconApple = new ImageIcon("apple.png"); //создаем новый обьект класса ЗначекИзображение
        //под соответствующим именем
        apple = imageIconApple.getImage(); //инициализируем поле класса "яблоко"

        ImageIcon imageIconSnakeCell = new ImageIcon("ball.png"); //создаем новый обьект класса ЗначекИзображение
        //под соответствующим именем
        snakeCell = imageIconSnakeCell.getImage(); //инициализируем поле класса "ячейка"
    }

    @Override
    protected void paintComponent(Graphics g) { //переопределенный метод который отрисовывает наше игровое поле
        super.paintComponent(g); //техническая перерисовка метода
        if (inGame) { //если мы в игре, то
            g.drawImage(apple, apple_X, apple_Y, this); //перерисовываем картинку яблока (this - обьект,
            // который отвечает за картинку,т.е. обьект, который перерисовывает)

            for (int i = 0; i < snakeCells; i++) { //при помощи цикла перерисовываем нашу змейку (сколько элементов, столько
                // перерисовок)
                g.drawImage(snakeCell, x[i], y[i], this); //рисуется элемент змейки(все элементы одинаковые
            }
        } else {
            String gameOver = "GAME OVER!"; //создаем строковую переменную и инициализируем ее литералом КОНЕЦ ИГРЫ
            Font fontGameOver = new Font("Arial", Font.BOLD, 18); //создаем новый обьект Шрифт с аргументами
            // название шрифта/размер/жирный шрифт
            g.setColor(Color.red); //устанавливаем цвет строке
            g.setFont(fontGameOver); //устанавливаем строке созданный шрифт
            g.drawString(gameOver, 110, SIZE/2); //рисуем нашу фразу для проигрыша

        }
    }

    public void move() { //метод для движения змейки, будет происходить логическая прорисовка точек, будут сдвигаться в
        //масиве Х и У, которые мы задали для хранения позиций ячеек
        for (int i = snakeCells; i > 0; i--) {
            x[i] = x[i - 1]; //выполняем смещение точек по Х (которые не голова) на предидущие позиции
            y[i] = y[i - 1]; //выполняем смещение точек по У (которые не голова) на предидущие позиции
        }
        if (left) { //если направление головы ВЛЕВО, то
            x[0] -= IMAGE_SIZE; //берем наш нулевой Х перемещаем его на минус размер ячеек
        }
        if (right) { //если направление головы ВПРАВО, то
            x[0] += IMAGE_SIZE; //берем наш нулевой Х перемещаем его на плюс размер ячеек
        }
        if (up) { //если направление головы ВВЕРХ, то
            y[0] -= IMAGE_SIZE; //берем наш нулевой У перемещаем его на минус размер ячеек
        }
        if (down) { //если направление головы ВНИЗ, то
            y[0] += IMAGE_SIZE; //берем наш нулевой У перемещаем его на плюс размер ячеек
        }
    }

    public void checkAppleOnTheWay() { //метод, который проверяет встретилось ли нам яблоко на пути
        if (x[0] == apple_X && y[0] == apple_Y) { //если координаты головы змейки будут равны координатам яблока, то
            snakeCells++; //увеличиваем блину тела змейки
            createApple(); //и создаем новое рандомное яблоко на игровом поле
        }
    }

    public void checkCollisionWithUs() { //проверяем не врезались мы сами в себя
        for (int i = snakeCells; i > 0; i--) {
            if (i > 4 && x[0] == x[i] && y[0] == y[i]) { //если длина змейки более 4 ячеек (только так можно наткнуться
                // на себя) и голово не уткнулась в наше же тело, то
                inGame = false; //конец игре
            }
        }
    }

    public void checkCollisionWithFields() { //проверяем не врезались ли мы в стены
        if (x[0] >= SIZE) { //если координата головы змейки по Х вышла за пределы поля правой стороны, то
            inGame = false; //конец игры
        }
        if (x[0] < 0) { //если координата головы змейки по Х вышла за пределы поля левой стороны, то
            inGame = false; //конец игры
        }
        if (y[0] >= SIZE) { //если координата головы змейки по У вышла за пределы поля правой стороны, то
            inGame = false; //конец игры
        }
        if (y[0] < 0) { //если координата головы змейки по У вышла за пределы поля левой стороны, то
            inGame = false; //конец игры
        }
    }


    @Override
    public void actionPerformed(ActionEvent e) { //метод для проверки ДействиеВыполнено()
        //данный метод будет вызываться каждые 300 миллисекунды, которые мы
        //установили при создании нового Таймера в методе инициализацияИгры()
        if (inGame) { //если мы в игре, то
            checkAppleOnTheWay(); //вызываем метод, кот.проверяет попалось ли нам яблоко по пути
            checkCollisionWithUs(); //вызываем метод, кот.проверяет не врезались ли мы в свое тело
            checkCollisionWithFields(); //вызываем метод, кот.проверяет не врезались ли мы в поля игрового поля
            move(); //вызываем метод двигать()
        }
        repaint(); //метод который вызывает метод paintComponent(), который перерисовывает поле (может вызываться нами,
        //а может вызываться автоматически операционной системой)
    }

    class FieldKeyListener extends KeyAdapter { //класс ОбработчикСобытий который будет расширять класс KeyAdapter

        @Override
        public void keyPressed(KeyEvent e) {
            super.keyPressed(e);
            int key = e.getKeyCode(); //создаем переменную, которой присваиваем значение равное = получить код, который
            //был выполнен с клавишей - код клавиш, которые были нажаты
            if (key == KeyEvent.VK_LEFT && !right) { //если нажато ВЛЕВО и я не двигаюсь вправо (что координально
                //невозможно, т.к. можно выполнить движение только вверх или вниз перед поворотом)
                left = true; //направление ВЛЕВО - истинно
                up = false; //-ложно
                down = false; //-ложно
            }
            if (key == KeyEvent.VK_RIGHT && !left) { //если нажато ВПРАВО и я не двигаюсь влево (что координально
                //невозможно, т.к. можно выполнить движение только вверх или вниз перед поворотом)
                right = true; //направление ВПРАВО - истинно
                up = false; //-ложно
                down = false; //-ложно
            }
            if (key == KeyEvent.VK_UP && !down) { //если нажато ВВЕРХ и я не двигаюсь вниз (что координально
                //невозможно, т.к. можно выполнить движение только вправо или влево перед поворотом)
                right = false; //-ложно
                up = true; //направление ВВЕРХ - истинно
                left = false; //-ложно
            }
            if (key == KeyEvent.VK_DOWN && !up) { //если нажато ВНИЗ и я не двигаюсь вверх (что координально
                //невозможно, т.к. можно выполнить движение только вправо или влево перед поворотом)
                right = false; //-ложно
                down = true; //направление ВНИЗ - истинно
                left = false; //-ложно
            }
        }
    }
}
